#!/usr/bin/env python3

import sqlite3
import base64
import os
import sys
import tempfile
import argparse
import subprocess
from io import StringIO
from colorama import Fore, Back, Style
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter, landscape

standard_start = " " + Fore.WHITE + Back.RED + ' --- ' + Back.RESET + Fore.RESET + Style.RESET_ALL
standard_stop = " " + Fore.WHITE + Back.RED + ' --- ' + Back.RESET + Fore.RESET + Style.RESET_ALL


def print_with_intention(_string, newline=True, tab=False):
    new_line = "\n" if newline else " "
    _tab = "\t" if tab else " "

    # Informational Statement
    if _string.startswith("[i] "):
        print(_tab + Fore.WHITE + Back.BLUE + "[i]" + Back.RESET + Fore.RESET + " " +
              Style.RESET_ALL + Fore.WHITE + Back.BLUE + _string[4:] + Back.RESET + Fore.RESET + new_line)
    # Declarative Statement
    elif _string.startswith("[+] "):
        print(_tab + Fore.BLACK + Back.GREEN + "[+]" + Back.RESET + Fore.RESET + " " +
              Style.RESET_ALL + Fore.BLACK + Back.GREEN + _string[4:] + Fore.RESET + Back.RESET + new_line)
    # Addendum or Continuation
    elif _string.startswith("[^] "):
        print(_tab + Fore.WHITE + Back.RED + " > " + Back.RESET + Fore.RESET + " " +
              Style.RESET_ALL + _string[4:] + Fore.RESET + Back.RESET + new_line)
    elif _string.startswith("[-] "):
        print(_tab + Fore.BLACK + Back.GREEN + " > " + Back.RESET + Fore.RESET + " " +
              Style.RESET_ALL + _string[4:] + Fore.RESET + Back.RESET + new_line)
    # Error or Alert Notification
    elif _string.startswith("[!] "):
        print(_tab + Fore.WHITE + Back.RED + "[!]" + Back.RESET + Fore.RESET + " " +
              Style.RESET_ALL + Fore.WHITE + Back.RED + _string[4:] + Fore.RESET + Back.RESET + new_line)
    # System Errors
    elif _string.startswith("[x] ") or _string.startswith("[X] "):
        print(_tab + "\t\t" + Fore.YELLOW + Back.RED + "[x]" + Back.RESET + Fore.RESET + " " +
              Style.RESET_ALL + Fore.YELLOW + Back.RED + _string[4:] + Fore.RESET + Back.RESET + new_line)


def decode_base64(data):
    try:
        return base64.b64decode(data).decode('utf-8')
    except Exception as e:
        print(f"Error decoding base64 data: {e}")
        return str(data) # Ensure data is returned as string even if it can't be decoded.


def print_rows(rows, show_stdout):
    global standard_start, standard_stop
    for i, row in enumerate(rows, start=1):
        command = decode_base64(row[2])
        
        if command.startswith('cn '):
            continue
        
        note = decode_base64(row[4])
        nfilename = os.path.basename(row[0])
        print('\n')
        print_with_intention(f'[+] CMD {row[5]} ({row[1]}) --> {nfilename}')
        print_with_intention(f'[^] {command}')
        note_content = note.lstrip("cn ")
        # print_with_intention(f'[i] Log Path: {row[0]}')
        
        if note_content:
            print_with_intention(f'[i] {note_content}')
        
        if show_stdout:
            print(f'{standard_start}\n\n{row[3].decode()}\n\n{standard_stop}\n')


def search_database(database, search_term=None, mode=None, n=1, show_stdout=False):
    try:
        conn = sqlite3.connect(database)
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()
        for table in tables:
            if 'notes' in table:
                cursor.execute(f"SELECT * FROM {table[0]}")
                rows = cursor.fetchall()
                for i in range(len(rows)):
                    row = rows[i]
                    if search_term and (search_term in decode_base64(row[2]) or search_term in decode_base64(row[4]) or search_term in str(row[3])):
                        if mode == 'before':
                            if i - n >= 0:
                                print_rows(rows[i-n:i], show_stdout)
                        elif mode == 'after':
                            if i + n < len(rows):
                                print_rows(rows[i:i+n+1], show_stdout)
                        else:
                            print_rows([row], show_stdout)
                    elif not search_term:
                        print_rows([row], show_stdout)
        conn.close()
    except Exception as e:
        print_with_intention(f"[!] CLOOK Error processing database {database}: {e}")


class Tee(object):
    def __init__(self, *files):
        self.files = files
    def write(self, obj):
        for file in self.files:
            file.write(obj)
    def flush(self):
        for file in self.files:
            file.flush()


def main():
    parser = argparse.ArgumentParser(description='Search in sqlite databases.')
    parser.add_argument('-s', '--search', type=str, help='The search term')
    parser.add_argument('-m', '--mode', type=str, help='Mode, either "before" or "after"')
    parser.add_argument('-n', type=int, default=1, help='Number of rows to print before or after the match')
    parser.add_argument('-d', '--dir', type=str, default='.', help='Directory to search for databases')
    parser.add_argument('-o', '--stdout', action='store_true', help='Option to show stdout')
    parser.add_argument('-p', '--pdf', action='store_true', help='Generate PDF output')
    args = parser.parse_args()

    for database in os.listdir(args.dir):
        if database.endswith('.db'):
            # If PDF output is requested, capture stdout in addition to printing to console
            if args.pdf:
                stdout_string = StringIO()
                sys.stdout = Tee(sys.stdout, stdout_string)

            if args.search:
                search_database(os.path.join(args.dir, database), args.search, args.mode, args.n, args.stdout)
            else:
                search_database(os.path.join(args.dir, database), show_stdout=args.stdout)

            # If PDF output was requested, write captured stdout string to PDF
            if args.pdf:
                # Write stdout_string to a temporary file
                with tempfile.NamedTemporaryFile(delete=False) as tmp:
                    tmp.write(stdout_string.getvalue().encode())
                    tmp_filename = tmp.name

                # Run cxrmclear on the temporary file
                subprocess.run(['cxrmclear', '-qf', tmp_filename])

                # Read the sanitized contents back into stdout_string_sanitized
                with open(tmp_filename, 'r') as tmp:
                    stdout_string_sanitized = tmp.read()

                # Delete the temporary file
                os.remove(tmp_filename)

                # Generate PDF filename based on database name
                pdf_filename = os.path.splitext(database)[0] + '.pdf'

                # Write sanitized stdout string to PDF
                c = canvas.Canvas(pdf_filename, pagesize=landscape(letter))
                width, height = landscape(letter)
                c.setFont("Courier", 10)
                x = 10
                y = height - 10
                for line in stdout_string_sanitized.split('\n'):
                    if y < 10:
                        c.showPage()
                        y = height - 10
                    c.drawString(x, y, line)
                    y -= 10
                c.save()

                # Reset stdout for the next database
                sys.stdout = sys.stdout.files[0]


if __name__ == "__main__":
    main()

