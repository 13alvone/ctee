#!/usr/bin/env bash

# User Configs
age_out_days=1
age_out_count=20

echo ""
echo "░█████╗░████████╗███████╗███████╗"
echo "██╔══██╗╚══██╔══╝██╔════╝██╔════╝"
echo "██║░░╚═╝░░░██║░░░█████╗░░█████╗░░"
echo "██║░░██╗░░░██║░░░██╔══╝░░██╔══╝░░"
echo "╚█████╔╝░░░██║░░░███████╗███████╗"
echo "░╚════╝░░░░╚═╝░░░╚══════╝╚══════╝"
echo ""
echo "［ＲＥＣ］"
echo ""

if [ "$(id -u)" = "0" ]; then
    echo "[x] This script should not be started with with SUDO but will request it for a few subcommands.." >&2
    exit 1
fi

# Set Current Directory as Starting Directory
starting_dir=$(pwd)

# Check for updates on each run and update if remote change detected
$HOME/.ctee/git/update.sh

set -e # Exit on error

# Define directory to save output files
output_dir=$HOME/.ctee/
script_dir=$(dirname "$0")

# Function to cleanup temp files and remove pid file
function cleanup {
  echo ""
  echo "    [i] Cleaning up..."
  rm -f "$temp_bashrc"
  rm -f "$output_dir/ctee.pid" # remove pid file when script ends

  # Remove files older than 7 days
  find "$output_dir" -name "cli_record_*" -mtime +$age_out_days -exec rm {} \;
  find "$output_dir" -name "cli_timer_*" -mtime +$age_out_days -exec rm {} \;

  # If there are more than 'age_out_count' files, delete the oldest
  (ls -f -t1 $output_dir"cli_record_"* 2>/dev/null | head -n $age_out_count; ls -f $output_dir"cli_record_"* 2>/dev/null) | sort | uniq -u | xargs -I {} rm -f -- {}
  (ls -f -t1 $output_dir"cli_timer_"* 2>/dev/null | head -n $age_out_count; ls -f $output_dir"cli_timer_"* 2>/dev/null) | sort | uniq -u | xargs -I {} rm -f -- {}

  exit 0
}

# Register the cleanup function to be called on the EXIT signal
trap cleanup EXIT INT QUIT TERM HUP

# Generate a timestamp for unique filename
timestamp=$(date +%Y%m%d%H%M%S)
filename="cli_record_$timestamp"
ffilename="ctee_log_$timestamp"
tfilename="cli_timer_$timestamp"

# Check if the script utility is installed and accessible
if ! command -v script &> /dev/null
then
    echo "The 'script' utility could not be found. Please install it and try again."
    exit 1
fi

OS=$(uname -s)
if [ "$OS" = "Linux" ]
then
  # Check if the file exists
  bashrc_content_file=$HOME/.ctee/etc/bashrc.ctee
  if [[ -f "$bashrc_content_file" ]]; then
      # Create a temporary bashrc file
      temp_bashrc=$(mktemp)
      cat "$bashrc_content_file" >> "$temp_bashrc"
  else
      echo "[!] Warning: '$bashrc_content_file' does not exist."
      echo "    - If not installed previously, run 'install.sh' and try again..."
      echo "    - If previously installed, run 'update.sh' script to attempt auto-fix..."
      exit 1

  fi
elif [ "$OS" = "Darwin" ]
then
  # macOS specific commands
  echo "[i] MacOS Version Enabled."
  if ! brew list | grep util-linux &>/dev/null; then
    brew install util-linux
  fi
else
  echo '[!] Ctee currently only operates on MacOS and Linux systems. Exiting...'
  exit 1
fi

# Create the target directory if it doesn't already exist
mkdir -p $output_dir

# Write the pid to a file
echo $$ > $output_dir"ctee.pid"
output_cache_path=$output_dir"ctee_cache"

# Start recording with the 'script' command
# The --rcfile option ensures the temporary bashrc file is loaded
echo $OS
case $OS in
  Darwin)
    tfilename="NA_on_MacOS"
    script -q -t 0 -a "$output_dir$filename"
    echo ""
    echo "[+] CLI Recording File:"
    echo "$output_dir$filename"
    echo ""
    ;;
  Linux)
    script --timing="$output_dir$tfilename" -m advanced -a "$output_dir$filename" -q --command="bash --rcfile $temp_bashrc"
    # Normalize the timing file of the resulting timing file
    cxtiming -f "$output_dir$tfilename" -n 2
    echo ""
    echo "[+] CLI Recording File : CLI Recording Timer File"
    echo "    $output_dir$filename:$output_dir$tfilename"
    echo ""
    ;;
  *)
    echo "[!] Ctee currently only operates on MacOS and Linux systems. Exiting..."
    exit 1
    ;;
esac

echo "$output_dir$filename"
echo "$output_cache_path"
echo "$output_dir$filename:$output_dir$tfilename" > "$output_cache_path"

# Remove any non-printable control sequences, simulate backspaces, and clear actions with no-ops
cxrmclear

# Create a copy of the resulting logfile in the current working directory
cp $output_dir$filename $starting_dir/$ffilename
