#!/usr/bin/env python3

import os
import sys
import glob
import datetime
import sqlite3
import argparse
import subprocess

default_log = os.environ.get('CTEE_CURRENT_LOGFILE')


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('notes', type=str, help='Your notes string.', default="N/A", nargs='?')
    parser.add_argument('-n', '--line_numbers', type=int, help='Number of lines to print.', default=50)
    parser.add_argument('-f', '--logfile', help='Optional Logfile.', required=False, default=default_log)
    return parser.parse_args()


def get_current_history():
    global args
    # Execute the command, capture the stdout and stderr
    cmd = f'cxrmclear -l -f "{args.logfile}"'
    proc = subprocess.run(cmd, shell=True, check=True, text=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    # Returns STDOUT, STDERR
    if proc.stdout:
        return proc.stdout
    
    if proc.stderr:
        return f'[!] STDERR: `{proc.stderr}`'


def main():
    global args

    ctee_dir = os.path.expanduser('~/.ctee/')
    ctee_pid_file = os.path.join(ctee_dir, 'ctee.pid')

    # Check that ctee is running, exit if not.
    if not os.path.isfile(ctee_pid_file) or not os.getenv('CTEE_RECORDING') == "1":
        print("[!] Not running in a ctee shell. Start `ctee` first by invoking it directly and try `cxwrite` again.")
        return 1

    args = get_args()
    timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    database_path = os.path.join(ctee_dir, 'cxwrite_notes.db')

    if args.logfile:
        full_history = get_current_history().split('\n')
        last_n_lines = '\n'.join(full_history[len(full_history)-args.line_numbers:])
    
    else:    
        ctee_current_logfile = os.environ.get('CTEE_CURRENT_LOGFILE')
        # Get the last n lines of latest log file, where n is given by the command line argument --lines
        with open(ctee_current_logfile, 'r') as f:
            lines = f.readlines()
        last_n_lines = ''.join(lines[-args.line_numbers:])  # join lines into a single string

    # Create or connect to the SQLite database and insert the note
    conn = sqlite3.connect(database_path)
    c = conn.cursor()

    # Create table if it doesn't exist
    c.execute('''
        CREATE TABLE IF NOT EXISTS notes (
            timestamp TEXT,
            note TEXT,
            additional_context TEXT
        )
    ''')

    # Insert the note
    c.execute('''
        INSERT INTO notes VALUES (?, ?, ?)
    ''', (timestamp, args.notes, last_n_lines))

    # Save (commit) the changes and close the connection
    conn.commit()
    conn.close()

    return 0


if __name__ == '__main__':
    sys.exit(main())

